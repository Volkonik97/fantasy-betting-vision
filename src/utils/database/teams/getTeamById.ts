
import { supabase } from "@/integrations/supabase/client";
import { Team } from "../../models/types";
import { toast } from "sonner";
import { getTeamsFromCache, updateTeamInCache } from "./teamCache";

/**
 * R√©cup√®re une √©quipe √† partir de la vue 'team_summary_view' ou de la table 'teams'
 * avec gestion du cache et fallback
 */
export const getTeamById = async (teamId: string): Promise<Team | null> => {
  try {
    if (!teamId) {
      console.error("ID d'√©quipe non fourni");
      return null;
    }
    
    // Essayer de r√©cup√©rer depuis le cache d'abord
    const cachedTeams = getTeamsFromCache();
    if (cachedTeams) {
      const cachedTeam = cachedTeams.find(team => team.id === teamId);
      if (cachedTeam) {
        console.log(`üß† √âquipe ${teamId} r√©cup√©r√©e depuis le cache`);
        return cachedTeam;
      }
    }

    // Essayer d'abord avec la vue team_summary_view
    let { data, error } = await supabase
      .from("team_summary_view")
      .select("*")
      .eq("id", teamId)
      .single();

    // Si la vue n'existe pas ou a un probl√®me, essayer avec la table teams
    if (error) {
      console.log("‚ùå Erreur lors du chargement depuis la vue, tentative avec la table teams");
      
      // Essai avec teamid (au cas o√π le nom de colonne est diff√©rent)
      const { data: teamData, error: teamError } = await supabase
        .from("teams")
        .select("*")
        .eq("id", teamId)
        .single();
      
      if (teamError) {
        // Essai avec une autre colonne potentielle
        const { data: fallbackData, error: fallbackError } = await supabase
          .from("teams")
          .select("*")
          .eq("teamid", teamId)
          .single();
          
        if (fallbackError) {
          console.error("‚ùå Toutes les tentatives de r√©cup√©ration de l'√©quipe ont √©chou√©:", 
            { viewError: error, tableError: teamError, fallbackError });
          toast.error("√âchec du chargement de l'√©quipe");
          return null;
        }
        
        data = fallbackData;
      } else {
        data = teamData;
      }
    }

    if (!data) {
      console.error(`‚ùå Aucune donn√©e pour l'√©quipe ${teamId}`);
      toast.error("√âquipe non trouv√©e");
      return null;
    }

    // Normaliser les donn√©es selon la structure attendue par l'appli
    const team: Team = {
      id: data.id || data.teamid,
      name: data.name || data.teamname,
      region: data.region,
      logo: data.logo,
      winRate: data.winrate || data.winrate_percent / 100 || 0,
      blueWinRate: data.winrate_blue || data.winrate_blue_percent / 100 || 0,
      redWinRate: data.winrate_red || data.winrate_red_percent / 100 || 0,
      averageGameTime: data.average_game_time || data.avg_gamelength || 0,
      // Ajouter d'autres propri√©t√©s selon la structure actuelle
      blueFirstBlood: data.firstblood_blue_pct || 0,
      redFirstBlood: data.firstblood_red_pct || 0,
      blueFirstDragon: data.blue_firstdragon_pct || 0,
      redFirstDragon: data.red_firstdragon_pct || 0,
      blueFirstHerald: data.blue_firstherald_pct || 0,
      redFirstHerald: data.red_firstherald_pct || 0,
      blueFirstTower: data.blue_firsttower_pct || 0,
      redFirstTower: data.red_firsttower_pct || 0,
      blueFirstBaron: data.blue_firstbaron_pct || 0,
      redFirstBaron: data.red_firstbaron_pct || 0
    };
    
    // Mettre √† jour l'√©quipe dans le cache
    updateTeamInCache(team);
    
    return team;
  } catch (error) {
    console.error("‚ùå Erreur inattendue dans getTeamById :", error);
    toast.error("Erreur serveur");
    return null;
  }
};
